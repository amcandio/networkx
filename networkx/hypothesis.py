"""Hypothesis strategies for generating NetworkX graphs with edge attributes."""

import inspect

import networkx as nx
from hypothesis import strategies as st

__all__ = ["edge_data_st", "graph_st"]


@st.composite
def edge_data_st(draw, **kwargs):
    """Draws a dictionary of edge attributes based on provided strategies.

    Parameters
    ----------
    **kwargs : dict
        Keyword arguments where each value is either:
        - A `hypothesis` strategy (e.g., `st.integers()`)
        - A constant value

    Returns
    -------
    dict
        A dictionary where each key maps to a drawn value or static value.

    Examples
    --------
    >>> edge_data_st(weight=st.integers(1, 10), label="A")
    Might return: {"weight": 5, "label": "A"}
    """
    return {
        k: draw(v) if isinstance(v, st.SearchStrategy) else v
        for k, v in kwargs.items()
    }


@st.composite
def graph_st(draw, graph_generator, edge_data_st=None, **kwargs) -> nx.Graph:
    """Draws a NetworkX graph from a generator function and optionally adds edge data.
    If the generator function accepts a 'seed' parameter, it will be automatically
    generated unless provided in `kwargs`.
    The edge attributes are generated using the `edge_data_st` strategy.

    All graph generators from NetworkX are off-the-shelf supported. For more details,
    see the `generators module documentation <https://networkx.org/documentation/stable/reference/generators.html>`_.
    For more details on the hypothesis framework, see library `documentation <https://hypothesis.readthedocs.io>`_.

    Parameters
    ----------
    graph_generator : callable
        A function that returns a NetworkX graph (e.g., `nx.erdos_renyi_graph`, `nx.random_labeled_tree`).
        In case of being a random generator, it must accept a `seed` parameter to ensure reproducibility.

    edge_data_st : SearchStrategy, optional
        A strategy (typically created by `edge_data_st(...)`) to generate edge attribute dictionaries.

    **kwargs : dict
        Additional arguments passed to `graph_generator`. Each argument may be:
        - A `hypothesis` strategy
        - A constant value

    Returns
    -------
    networkx.Graph
        A graph instance generated by the given function, with edge attributes optionally added.

    Examples
    --------
    Using a random generator:

    >>> @given(graph_st(
    ...     nx.erdos_renyi_graph,
    ...     n=st.integers(5, 10),
    ...     p=st.floats(0.1, 0.5),
    ...     edge_data_st=edge_data_st(weight=st.integers(1, 100))
    ... ))
    ... def test_weighted_erdos_renyi(G):
    ...     for u, v, d in G.edges(data=True):
    ...         assert "weight" in d

    Using a deterministic generator:

    >>> @given(graph_st(
    ...     nx.path_graph,
    ...     n=st.integers(2, 20)
    ... ))
    ... def test_path_graph(G):
    ...     assert nx.diameter(G) == G.number_of_nodes() - 1

    Other supported examples:

    - Balanced trees:
      >>> graph_st(nx.balanced_tree, r=st.integers(2, 3), h=st.integers(1, 4))

    - Grid graphs:
      >>> graph_st(nx.grid_2d_graph, m=st.integers(2, 4), n=st.integers(2, 4))

    - Complete graphs:
      >>> graph_st(nx.complete_graph, n=st.integers(1, 10), edge_data_st=edge_data_st(val=st.just(1)))

    - Small-world and scale-free graphs:
      >>> graph_st(nx.watts_strogatz_graph, n=st.integers(10, 30), k=st.integers(2, 6), p=st.floats(0, 1))
      >>> graph_st(nx.barabasi_albert_graph, n=st.integers(10, 30), m=st.integers(1, 5))
    """
    # Prepare parameters for the graph generator
    params = {}
    signature = inspect.signature(graph_generator)

    # If the graph generator accepts a 'seed' and none is provided, generate one
    if "seed" not in kwargs and "seed" in signature.parameters:
        params["seed"] = draw(st.randoms())

    for k, v in kwargs.items():
        params[k] = draw(v) if isinstance(v, st.SearchStrategy) else v

    G = graph_generator(**params)

    # Optionally add edge attributes using the provided strategy
    if edge_data_st is not None:
        for u, v in G.edges():
            G[u][v].update(draw(edge_data_st))

    return G
